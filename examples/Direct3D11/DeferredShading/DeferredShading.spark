// Copyright 2011 Intel Corporation
// All Rights Reserved
//
// Permission is granted to use, copy, distribute and prepare derivative works of this
// software for any purpose and without fee, provided, that the above copyright notice
// and this statement appear in all copies.  Intel makes no representations about the
// suitability of this software for any purpose.  THIS SOFTWARE IS PROVIDED "AS IS."
// INTEL SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, AND ALL LIABILITY,
// INCLUDING CONSEQUENTIAL AND OTHER INDIRECT DAMAGES, FOR THE USE OF THIS SOFTWARE,
// INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PROPRIETARY RIGHTS, AND INCLUDING THE
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Intel does not
// assume any responsibility for any errors which may appear in this software nor any
// responsibility to update it.


abstract shader class Base extends D3D11DrawPass
{
    // @Uniform
    // 
    input @Uniform float4x4          world;
    input @Uniform float4x4          view;
    input @Uniform float4x4          proj;
    input @Uniform float4            objectColor;
    input @Uniform Texture2D[float4] diffuseTexture;
    input @Uniform SamplerState      linearSampler;

    // @AssembledVertex
    //
    struct PNU
    {
        float3 position;
        float3 normal;
        float2 texCoord;
    }

    input @Uniform VertexStream[PNU] myVertexStream;
    input @Uniform DrawSpan myDrawSpan;
    input @Uniform float3            lightDir;
    input @Uniform float             ambient;
//    input @Uniform float3            cameraPos;
//    abstract output @Pixel float4 myTarget ;

}

abstract mixin shader class SurfaceAttributes extends D3D11DrawPass
{
    abstract @Fragment float3 positionView;         // View space position
    abstract @Fragment float3 normal;               // View space normal
    abstract @Fragment float4 albedo;
    abstract @Fragment float specularAmount;        // Treated as a multiplier on albedo
    abstract @Fragment float specularPower;
}

abstract mixin shader class GenerateSurfaceAttributes
    extends Base, SurfaceAttributes
{
    @Uniform float4x4 worldview = mul(world, view);
    @Uniform float4x4 viewProj      = mul( view, proj );
    @Uniform float4x4 worldViewProj = mul( world, viewProj );


    @AssembledVertex PNU    fetched  = myVertexStream( IA_VertexID );
    @AssembledVertex float3 P_model  = fetched.position;
    @AssembledVertex float3 N_model  = fetched.normal;
    @AssembledVertex float2 texCoord = fetched.texCoord;

    override IA_DrawSpan = myDrawSpan;

    // @CoarseVertex
    //
    @CoarseVertex float3 N_world = mul(N_model, float3x3(world));
//    @CoarseVertex float3 viewVec = normalize(cameraPos - mul(float4(P_model, 1.0f), world).xyz);
    @CoarseVertex float3 P_view = mul(float4(P_model,1.0f), worldview).xyz;

    // @RasterVertex
    //
    override RS_Position = mul(float4(P_model, 1.0f), worldViewProj);

    override positionView = P_view;         // View space position
    override normal = N_world;               // World space normal
    override albedo = Sample(diffuseTexture, linearSampler, texCoord);
    override specularAmount = 0.9f;        // Treated as a multiplier on albedo
    override specularPower = 25.0f;
}


abstract mixin shader class DirectionalLight
    extends Base, SurfaceAttributes
{

    //@Fragment float4 color = float4(normal, 1.0f);
    // @Pixel
    //
    @Fragment float4 diffuse  = albedo;
    @Fragment float  lighting = max(saturate(dot(lightDir, normal)), ambient);
    @Fragment float4 color    = diffuse * lighting ;

    output @Pixel float4 myTarget = color;
}


shader class Forward extends GenerateSurfaceAttributes, DirectionalLight
{}

abstract mixin shader class PackGBuffer
    extends Base, SurfaceAttributes
{
    float2 EncodeSphereMap(float3 n)
    {
        return n.xy * rsqrt(8.0f - 8.0f * n.z) + 0.5f;
    }

    @Fragment float4 normalSpecular = float4(EncodeSphereMap(normal),
                                                specularAmount,
                                                specularPower);

    @Fragment float2 positionZGrad = float2(ddx_coarse(positionView.z),
                                         ddy_coarse(positionView.z));

    output @Pixel float4 normalSpecularTarget = normalSpecular;
    output @Pixel float4 albedoTarget = albedo;
    output @Pixel float2 positionZGradTarget = positionZGrad;

}

shader class GenerateGBuffer extends GenerateSurfaceAttributes, PackGBuffer
{}

